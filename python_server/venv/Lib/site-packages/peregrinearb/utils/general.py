import math
import networkx as nx


class ExchangeNotInCollectionsError(Exception):
    def __init__(self, market_ticker):
        super(ExchangeNotInCollectionsError, self).__init__("{} is either an invalid exchange or has a broken API."
                                                            .format(market_ticker))

        
def getResult_Single(graph, path, round_to=None, depth=False, starting_amount=10):
    if not path:
        return 0

    # print("Starting with {} in {}".format(starting_amount, path[0]))

    results = {}
    for i in range(len(path)):
        if i + 1 < len(path):
            results[i]  = {}
            temp = {}
            
            start = path[i]
            end = path[i + 1]

            if depth:
                volume = min(starting_amount, math.exp(-graph[start][end]['depth']))
                starting_amount = math.exp(-graph[start][end]['weight']) * volume
            else:
                starting_amount *= math.exp(-graph[start][end]['weight'])

            if round_to is None:
                rate = math.exp(-graph[start][end]['weight'])
                resulting_amount = starting_amount
            else:
                rate = round(math.exp(-graph[start][end]['weight']), round_to)
                resulting_amount = round(starting_amount, round_to)

            # printed_line = "{} to {} at {} = {}".format(start, end, rate, resulting_amount)

            temp['start']            = start
            temp['end']              = end
            temp['rate']             = rate
            temp['resulting_amount'] = resulting_amount

            results[i]  = temp
            # todo: add a round_to option for depth
            if depth:
                printed_line += " with {} of {} traded".format(volume, start)

            # print(printed_line)

    return results

def getResult_Multi(graph: nx.Graph, path, print_output=True, round_to=None, shorten=False, starting_amount=10):
    """
    The only difference between this function and the function in utils/general.py is that the print statement
    specifies the exchange name. It assumes all edges in graph and in path have exchange_name and market_name
    attributes.
    """
    if not path:
        return 0

    money = starting_amount
    result = ''
    # result += "Starting with %(money)i in %(currency)s\n" % {"money": money, "currency": path[0]}
    results = {}
    for i in range(len(path)):
        if i + 1 < len(path):
            temp = {}
            results[i] = {}
            start = path[i]
            end = path[i + 1]
            rate = math.exp(-graph[start][end]['weight'])
            money *= rate

            # if round_to is None:
            #     result += "{} to {} at {} = {}".format(start, end, rate, money)
            # else:
            #     result += "{} to {} at {} = {}".format(start, end, round(rate, round_to), round(money, round_to))
            # if not shorten:
            #     result += " on {} for {}".format(graph[start][end]['exchange_name'], graph[start][end]['market_name'])

            result += '\n'

            temp['start']           = start
            temp['end']             = end
            temp['rate']            = round(rate, round_to)
            temp['money']           = round(money, round_to)
            temp['exchange_name']   = graph[start][end]['exchange_name']
            temp['market_name']     = graph[start][end]['market_name']

            results[i]  = temp

    # if print_output:
    #     print(result)
    return results
